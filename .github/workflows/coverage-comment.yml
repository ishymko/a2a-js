name: Post Coverage Comment

on:
  workflow_run:
    workflows: ["Run Unit Tests"]
    types:
      - completed

permissions:
  pull-requests: write
  actions: read

jobs:
  comment:
    runs-on: ubuntu-latest
    if: >
      github.event.workflow_run.event == 'pull_request' &&
      github.event.workflow_run.conclusion == 'success'
    steps:
      - name: Download Coverage Artifacts
        uses: actions/download-artifact@v4
        with:
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          name: coverage-data
      
      - name: Upload Coverage Report
        id: upload-report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage/
          retention-days: 14

      - name: Post Comment
        uses: actions/github-script@v6
        env:
          ARTIFACT_URL: ${{ steps.upload-report.outputs.artifact-url }}
        with:
          script: |
            const fs = require('fs');

            const loadSummary = (path) => {
              try {
                return JSON.parse(fs.readFileSync(path, 'utf8'));
              } catch (e) {
                console.log(`Could not read ${path}: ${e}`);
                return null;
              }
            };

            const mainSummary = loadSummary('./coverage-main-summary.json');
            const prSummary = loadSummary('./coverage-pr-summary.json');

            if (!mainSummary || !prSummary) {
              console.log("Missing coverage data, skipping comment.");
              return;
            }

            let markdown = `### ðŸ§ª Code Coverage\n\n`;
            
            markdown += `[â¬‡ï¸ **Download Full Report**](${process.env.ARTIFACT_URL})\n\n`;
            markdown += `#### Overall Coverage Summary\n`;
            markdown += `| Metric | Main | PR | Delta |\n`;
            markdown += `| :--- | :---: | :---: | :---: |\n`;

            const metrics = ['lines', 'statements', 'functions', 'branches'];
            const getPct = (summary, metric) => summary.total[metric].pct;

            metrics.forEach(metric => {
              const oldPct = getPct(mainSummary, metric);
              const newPct = getPct(prSummary, metric);
              const diff = (newPct - oldPct).toFixed(2);
              
              let icon = '';
              if (diff > 0) icon = 'ðŸŸ¢';
              else if (diff < 0) icon = 'ðŸ”´';
              else icon = 'âšªï¸';

              const diffStr = diff > 0 ? `+${diff}%` : `${diff}%`;
              markdown += `| **${metric}** | ${oldPct}% | ${newPct}% | ${icon} ${diffStr} |\n`;
            });

            const formatDiff = (oldPct, newPct) => {
              const diff = (newPct - oldPct).toFixed(2);
              
              let icon = '';
              if (diff > 0) icon = 'ðŸŸ¢';
              else if (diff < 0) icon = 'ðŸ”´';
              else icon = 'âšªï¸';

              const diffStr = diff > 0 ? `+${diff}%` : `${diff}%`;
              return `${icon} ${diffStr}`;
            };

            const fileDiffs = [];
            const allFiles = new Set([...Object.keys(mainSummary), ...Object.keys(prSummary)]);
            allFiles.delete('total');

            for (const file of allFiles) {
              const mainFile = mainSummary[file];
              const prFile = prSummary[file];

              const metricsData = {};
              let hasDiff = false;

              metrics.forEach(metric => {
                const oldPct = mainFile ? mainFile[metric].pct : 0;
                const newPct = prFile ? prFile[metric].pct : 0;
                if (oldPct !== newPct) {
                  hasDiff = true;
                }
                metricsData[metric] = { oldPct, newPct };
              });

              if (hasDiff) {
                fileDiffs.push({ file, metricsData });
              }
            }

            if (fileDiffs.length > 0) {
              markdown += `\n#### Per-File Coverage Changes\n`;
              const workspacePath = process.env.GITHUB_WORKSPACE ? process.env.GITHUB_WORKSPACE + '/' : '';
              
              fileDiffs.forEach(diff => {
                const relativeFilePath = diff.file.replace(workspacePath, '');
                markdown += `\n<details>\n`;
                markdown += `<summary><code>${relativeFilePath}</code></summary>\n\n`;
                markdown += `| Metric | Main | PR | Delta |\n`;
                markdown += `| :--- | :---: | :---: | :---: |\n`;
                
                metrics.forEach(metricName => {
                  const data = diff.metricsData[metricName];
                  const diffStr = formatDiff(data.oldPct, data.newPct);
                  markdown += `| **${metricName}** | ${data.oldPct}% | ${data.newPct}% | ${diffStr} |\n`;
                });
                
                markdown += `\n</details>\n`;
              });

            } else {
              markdown += `\n\nâœ… No changes in file coverage.`;
            }

            markdown += `\n\n_Generated by [coverage-comment.yml](https://github.com/a2aproject/a2a-js/actions/workflows/coverage-comment.yml)_`;

            const prNumber = fs.readFileSync('./PR_NUMBER', 'utf8').trim();

            if (!prNumber) {
              console.log("No PR number found.");
              return;
            }

            const { owner, repo } = context.repo;

            const comments = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number: prNumber,
            });

            const existingComment = comments.data.find(c => 
              c.body.includes('Generated by [coverage-comment.yml]') && 
              c.user.type === 'Bot'
            );

            if (existingComment) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: existingComment.id,
                body: markdown
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: markdown
              });
            }